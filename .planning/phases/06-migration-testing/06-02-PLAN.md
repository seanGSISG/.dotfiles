---
phase: 06-migration-testing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - bootstrap.sh
  - verify.sh
autonomous: true

must_haves:
  truths:
    - "Bootstrap output goes to both screen and a timestamped log file"
    - "verify.sh checks that tools exist on PATH and config files are deployed"
    - "verify.sh prints pass/fail per check with total summary"
    - "Bootstrap can be fetched and run via curl from GitHub raw URL"
  artifacts:
    - path: "bootstrap.sh"
      provides: "Tee logging to screen and log file"
      contains: "tee"
    - path: "verify.sh"
      provides: "Standalone verification script with pass/fail checks"
      contains: "check_pass\|check_fail"
  key_links:
    - from: "bootstrap.sh"
      to: "~/.dotfiles-bootstrap-*.log"
      via: "tee duplicates output to log file"
      pattern: "tee.*log"
    - from: "verify.sh"
      to: "tools on PATH"
      via: "command -v checks"
      pattern: "command -v"
---

<objective>
Add tee logging to bootstrap.sh and create standalone verify.sh script that validates the full environment after deployment.

Purpose: Logging enables post-mortem debugging when bootstrap runs on a fresh machine. Verify.sh provides repeatable validation that all tools and configs deployed correctly — usable immediately after bootstrap and anytime later.

Output: Bootstrap with dual output (screen + log), verify.sh with comprehensive checks.
</objective>

<execution_context>
@/home/vscode/.claude/get-shit-done/workflows/execute-plan.md
@/home/vscode/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-migration-testing/06-CONTEXT.md
@bootstrap.sh
@packages/apt-packages.txt
@packages/uv-tools.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add tee logging to bootstrap.sh</name>
  <files>bootstrap.sh</files>
  <action>
Add `tee` logging to bootstrap.sh so all output goes to both the screen AND a log file simultaneously.

Implementation:
1. At the top of `main()`, before any output, set up tee:
   ```bash
   # Log file with timestamp
   LOG_FILE="$HOME/.dotfiles-bootstrap-$(date +%Y%m%d_%H%M%S).log"

   # Redirect all output through tee (both stdout and stderr)
   exec > >(tee -a "$LOG_FILE") 2>&1
   ```

2. After the welcome banner, print the log file location:
   ```bash
   log_info "Logging to: $LOG_FILE"
   ```

3. In `print_summary()`, add at the end:
   ```bash
   echo ""
   echo "  ${BOLD}Log file:${RESET} $LOG_FILE"
   ```

IMPORTANT: The `exec > >(tee ...)` approach works in bash and handles both stdout and stderr. This must be placed before any output in main().

IMPORTANT: The tee redirect must NOT interfere with interactive prompts (age key paste, chsh password). The `read` command reads from stdin which is separate from stdout/stderr tee redirect, so this should work fine.

Also add a note near the top of the script (in the header comment) about the log file location convention: `~/.dotfiles-bootstrap-YYYYMMDD_HHMMSS.log`
  </action>
  <verify>
Run these checks:
- `bash -n bootstrap.sh` passes syntax check
- `grep -q 'tee' bootstrap.sh` — tee logging present
- `grep -q 'LOG_FILE' bootstrap.sh` — log file variable defined
- `grep -q 'dotfiles-bootstrap-' bootstrap.sh` — log file naming convention
  </verify>
  <done>
Bootstrap outputs to both screen and timestamped log file. Log file path printed during startup and in final summary. Interactive prompts still work correctly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create standalone verify.sh</name>
  <files>verify.sh</files>
  <action>
Create `verify.sh` in the dotfiles root (alongside bootstrap.sh). This is a standalone script that validates the environment is correctly set up — usable after bootstrap and anytime later.

Structure:
```bash
#!/usr/bin/env bash
# verify.sh - Validate WSL2 dev environment setup
# Run after bootstrap.sh or anytime to check environment health
```

Color setup (same tput pattern as bootstrap.sh with fallbacks).

Counters: `PASSED=0`, `FAILED=0`, `WARNINGS=0`

Check functions (use Unicode checkmark/X per CONTEXT.md spec):
```bash
check_pass() { echo "${GREEN}  ✓${RESET} $1"; ((PASSED++)); }
check_fail() { echo "${RED}  ✗${RESET} $1"; ((FAILED++)); }
check_warn() { echo "${YELLOW}  ⚠${RESET} $1"; ((WARNINGS++)); }
```

Group checks into sections with headers:

**1. Shell Configuration**
- Default shell is zsh: `[ "$SHELL" = "/usr/bin/zsh" ]`
- .zshrc exists: `[ -f ~/.zshrc ]`
- Zsh config directory exists: `[ -d ~/.config/zsh ]`
- Antidote installed: `[ -d ~/.antidote ]`

**2. Tools on PATH**
Check each tool with `command -v`:
- chezmoi, starship, fnm, fzf, zoxide, uv, bun, gh, tmux, git, age, claude

**3. Config Files Deployed**
Check each file exists:
- ~/.zshrc
- ~/.bashrc
- ~/.profile
- ~/.gitconfig
- ~/.config/zsh/exports.zsh
- ~/.config/zsh/plugins.zsh
- ~/.config/zsh/tools.zsh
- ~/.config/zsh/aliases/ directory
- ~/.config/starship.toml
- ~/.config/tmux/tmux.conf

**4. SSH Keys**
- ~/.ssh/ directory exists with 700 permissions
- SSH private key exists (idm-prod-key): `[ -f ~/.ssh/idm-prod-key ]`
- SSH private key permissions are 600
- SSH public key exists: `[ -f ~/.ssh/idm-prod-key.pub ]`

**5. Secrets & Encryption**
- Age key exists: `[ -f ~/.config/age/keys.txt ]`
- Secrets file exists: `[ -f ~/.secrets.env ]`

**6. WSL2 Configuration**
- /etc/wsl.conf exists with systemd=true: `grep -q 'systemd=true' /etc/wsl.conf`

**7. Workspace Folders**
- ~/projects/ exists
- ~/labs/ exists
- ~/tools/ exists
- ~/tmp/ exists
- ~/command-center/ exists

**8. Claude Code**
- claude command available: `command -v claude`
- ~/.claude/ directory exists
- hooks.json exists: `[ -f ~/.claude/hooks.json ]`

**Summary section at end:**
```
═══════════════════════════════════════════
  Verification Summary
═══════════════════════════════════════════

  Passed:   XX
  Failed:   XX
  Warnings: XX
  Total:    XX

  ✓/✗ Environment is [ready/not ready]
```

Exit code: 0 if no failures, 1 if any failures.

Make the script executable: `chmod +x verify.sh`

Add verify.sh to .chezmoiignore (it's a repo-only utility, not deployed to home directory).
  </action>
  <verify>
Run these checks:
- `bash -n verify.sh` passes syntax check
- `[ -x verify.sh ]` — script is executable
- `grep -c 'check_pass\|check_fail' verify.sh` — has meaningful number of checks (20+)
- `grep -q '✓' verify.sh && grep -q '✗' verify.sh` — uses Unicode checkmark/X symbols
- `grep -q 'PASSED\|FAILED' verify.sh` — summary counters present
- `grep -q 'verify.sh' .chezmoiignore` — excluded from chezmoi apply
- Running `bash verify.sh` produces output with checkmark/X lines (Unicode ✓/✗ symbols)
  </verify>
  <done>
verify.sh exists as standalone script with 30+ checks across 8 categories. Prints pass/fail per check with summary totals. Exit code reflects overall status. Script is in .chezmoiignore (repo-only, not deployed).
  </done>
</task>

</tasks>

<verification>
1. `bash -n bootstrap.sh` — syntax check passes
2. `bash -n verify.sh` — syntax check passes
3. `grep -q 'tee' bootstrap.sh` — logging present
4. `grep -q 'LOG_FILE' bootstrap.sh` — log file path defined
5. Run `bash verify.sh` on current machine — produces readable output with checks
6. `grep -q 'verify.sh' .chezmoiignore` — excluded from chezmoi deployment
</verification>

<success_criteria>
- Bootstrap outputs to both screen and log file simultaneously
- verify.sh runs standalone with pass/fail checks across all environment aspects
- verify.sh exit code reflects success (0) or failure (1)
- Both scripts pass bash syntax check
</success_criteria>

<output>
After completion, create `.planning/phases/06-migration-testing/06-02-SUMMARY.md`
</output>
